# Binary Exploitation
## Background Knowledge
### Shellcode
- We ususally use shellcode to run `execve("/bin/sh", NULL, NULL)`, in this class, we run `sendfile(1, open("/flag", NULL), 0, 1000)` to read the flag by exploiting a privileged program
- *Building Shellcode*
    1. Write the shellcode as assembly
    2. And then assemble it using `gcc -nostdlib -static shellcode.s -o shellcode-elf`, the ELF has our shellcode as its `.text`
    3. Extract the `.text`: `objcopy --dump-section .text=shellcode-raw shellcode-elf`
    4. Now, `shellcode-raw` contains the raw bytes of our shellcode
- Test the shellcode
    - Run the ELF: `./shellcode-elf`
    - Write a shellcode loader in C:
        ```
        page = mmap(0x1337000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, 0, 0);
        read(0, page, 0x1000);
        ((void(*)())page)();
        ```
        - `cat shellcode-raw | ./tester`
- Debugging Shellcode:
    - `stract ./shellcode-elf`
    - `gdb ./shellcode-elf`
        - we can hardcode breakpoints in the shellcode using `int3` instruction
## Challenges
### Web Security
- *level 15*: there is a buffer overflow vulnerability, the program will store a string `Hello, <USER_INPUT>!` into a 256-byte buffer, but there isn't a size check on the user input. The server provides a function to print out the address of the `win()` function, which displays the flag. What we need to do is to overwrite the return address of the `greet()` function to the address of `win()`. The structure of the current stack frame is (from low address to high address):
    - `[buffer (256 bytes)][previous rbp (8 bytes)][return address]` (stack layout)
    - `['Hello, ' (7 bytes) +  padding (257 bytes)][  win_address ]` (buffer overflow)
### Shellcode Injection
- *level 1*: it will take in the raw bytes of our shellcode, and execute it on stack. We should put our data on stack instead of in `.data` section
- *level 2*: it will randomly skip up to `0x800` bytes of our code, to increase the probability that our instructions are not skipped, pad `0x900` bytes of NOPs (`0x90`) to our program
    - `.fill 0x900, 1, 0x90`
- *level 3*: we cannot have NULL bytes (`0x00`) in our shellcode. We can achieve that by replacing `mov <REGISTER>, 0` to `xor <REGISTER>, <REGISTER>`. Besides, `mov rax, 0x67616c662f` will also contain NULL bytes, because `0x67616c662f` will be padded to 8 bytes (`rax` is 8-byte register), there are many tricks to eliminate the NULL bytes, e.g.:
    ```
    # mov rax, 0x67616c662f
    mov rax, 0x67616c662f777777
    shr rax, 24
    ```
### Memory Errors
- *level 1.0*

### Program Exploitation