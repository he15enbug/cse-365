# Binary Exploitation
## Background Knowledge
### Shellcode
- We ususally use shellcode to run `execve("/bin/sh", NULL, NULL)`, in this class, we run `sendfile(1, open("/flag", NULL), 0, 1000)` to read the flag by exploiting a privileged program
- *Building Shellcode*
    1. Write the shellcode as assembly
    2. And then assemble it using `gcc -nostdlib -static shellcode.s -o shellcode-elf`, the ELF has our shellcode as its `.text`
    3. Extract the `.text`: `objcopy --dump-section .text=shellcode-raw shellcode-elf`
    4. Now, `shellcode-raw` contains the raw bytes of our shellcode
- Test the shellcode
    - Run the ELF: `./shellcode-elf`
    - Write a shellcode loader in C:
        ```
        page = mmap(0x1337000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, 0, 0);
        read(0, page, 0x1000);
        ((void(*)())page)();
        ```
        - `cat shellcode-raw | ./tester`
- Debugging Shellcode:
    - `stract ./shellcode-elf`
    - `gdb ./shellcode-elf`
        - we can hardcode breakpoints in the shellcode using `int3` instruction
## Challenges
- *level 1*: there is a buffer overflow vulnerability, the program will store a string `Hello, <USER_INPUT>!` into a 256-byte buffer, but there isn't a size check on the user input. The server provides a function to print out the address of the `win()` function, which displays the flag. What we need to do is to overwrite the return address of the `greet()` function to the address of `win()`. The structure of the current stack frame is (from low address to high address):
    - `[buffer (256 bytes)][previous rbp (8 bytes)][return address]` (stack layout)
    - `['Hello, ' (7 bytes) +  padding (257 bytes)][  win_address ]` (buffer overflow)
- *level 2*: it will take in the raw bytes of our shellcode, and execute it on stack. We should put our data on stack instead of in `.data` section
- *level 3*:
- *level 4*: