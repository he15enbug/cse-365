# Binary Exploitation
## Background Knowledge
### Shellcode
- We ususally use shellcode to run `execve("/bin/sh", NULL, NULL)`, in this class, we run `sendfile(1, open("/flag", NULL), 0, 1000)` to read the flag by exploiting a privileged program
- *Building Shellcode*
    1. Write the shellcode as assembly
    2. And then assemble it using `gcc -nostdlib -static shellcode.s -o shellcode-elf`, the ELF has our shellcode as its `.text`
    3. Extract the `.text`: `objcopy --dump-section .text=shellcode-raw shellcode-elf`
    4. Now, `shellcode-raw` contains the raw bytes of our shellcode
- Test the shellcode
    - Run the ELF: `./shellcode-elf`
    - Write a shellcode loader in C:
        ```
        page = mmap(0x1337000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, 0, 0);
        read(0, page, 0x1000);
        ((void(*)())page)();
        ```
        - `cat shellcode-raw | ./tester`
- Debugging Shellcode:
    - `stract ./shellcode-elf`
    - `gdb ./shellcode-elf`
        - we can hardcode breakpoints in the shellcode using `int3` instruction
## Challenges
### Web Security
- *level 15*: there is a buffer overflow vulnerability, the program will store a string `Hello, <USER_INPUT>!` into a 256-byte buffer, but there isn't a size check on the user input. The server provides a function to print out the address of the `win()` function, which displays the flag. What we need to do is to overwrite the return address of the `greet()` function to the address of `win()`. The structure of the current stack frame is (from low address to high address):
    - `[buffer (256 bytes)][previous rbp (8 bytes)][return address]` (stack layout)
    - `['Hello, ' (7 bytes) +  padding (257 bytes)][  win_address ]` (buffer overflow)
### Shellcode Injection
- *level 1*: it will take in the raw bytes of our shellcode, and execute it on stack. We should put our data on stack instead of in `.data` section
- *level 2*: it will randomly skip up to `0x800` bytes of our code, to increase the probability that our instructions are not skipped, pad `0x900` bytes of NOPs (`0x90`) to our program
    - `.fill 0x900, 1, 0x90`
- *level 3*: we cannot have NULL bytes (`0x00`) in our shellcode. We can achieve that by replacing `mov <REGISTER>, 0` to `xor <REGISTER>, <REGISTER>`. Besides, `mov rax, 0x67616c662f` will also contain NULL bytes, because `0x67616c662f` will be padded to 8 bytes (`rax` is 8-byte register), there are many tricks to eliminate the NULL bytes, e.g.:
    ```
    # mov rax, 0x67616c662f
    mov rax, 0x67616c662f777777
    shr rax, 24
    ```
### Memory Errors
- *level 1.0*: pretty straightforward, just overflow the buffer with any non-zero bytes to change the `win` byte to non-zero
- *level 1.1*: this time, the stack information is not given. First, try a longer input, e.g., 600 bytes, and we get the flag
- *level 2.0*: set the variable `win` to a given value
- *level 2.1*: this time, no useful information is printed out, debug the program to find the way to get the flag. We can know the buffer is at `rbp-0x60`, and there are 2 key jumping
    ```
    0x55df49fc3425 <challenge+188>:      call   0x55df49fc2180 <read@plt>
    0x55df49fc342a <challenge+193>:      mov    DWORD PTR [rbp-0x7c],eax
    0x55df49fc342d <challenge+196>:      cmp    DWORD PTR [rbp-0x7c],0x0
    0x55df49fc3431 <challenge+200>:      jns    0x55df49fc345f <challenge+246>
    ...
    0x55df49fc345f <challenge+246>:      mov    rax,QWORD PTR [rbp-0x68]
    0x55df49fc3463 <challenge+250>:      mov    eax,DWORD PTR [rax]
    0x55df49fc3465 <challenge+252>:      cmp    eax,0x3be21a84
    0x55df49fc346a <challenge+257>:      jne    0x55df49fc3476 <challenge+269>
    0x55df49fc346c <challenge+259>:      mov    eax,0x0
    0x55df49fc3471 <challenge+264>:      call   0x55df49fc326c <win>
    ```
    - `DWORD PTR [rbp-0x7c]` is the return value of `read()`, as long as it succeed to read our data, it returns a non-negative value. So, our goal is to set the 4-byte value at `[rbp-0x68]` to `0x3be21a84`. To know the address of this value, we need to figure out the content in `rbp-0x68`: it's `rbp-0x18`. So, we need to set the value at `buffer[72]`
        ```
        0x55df49fc33c0 <challenge+87>:       lea    rax,[rbp-0x60]
        0x55df49fc33c4 <challenge+91>:       add    rax,0x48
        0x55df49fc33c8 <challenge+95>:       mov    QWORD PTR [rbp-0x68],rax
        ```
    - After that, there will also be a stack check, to bypass it, we need the `xor` result to be zero. At the beginning of both `main()` and `challenge()`, `QWORD PTR fs:0x28` is put into `QWORD PTR [rbp-0x8]`, we just need to ensure we don't overwrite it when causing a buffer overflow (our input should be at most 88 bytes)
        ```
        0x55df49fc3482 <challenge+281>:      mov    eax,0x0
        0x55df49fc3487 <challenge+286>:      mov    rcx,QWORD PTR [rbp-0x8]
        0x55df49fc348b <challenge+290>:      xor    rcx,QWORD PTR fs:0x28
        0x55df49fc3494 <challenge+299>:      je     0x55df49fc349b <challenge+306>
        0x55df49fc3496 <challenge+301>:      call   0x55df49fc2150 <__stack_chk_fail@plt>
        0x55df49fc349b <challenge+306>:      leave  
        ```
- *level 3.0*: overwrite the return address to `0x402265` at `buffer[136]`
- *level 3.1*: debug the program to find the address of `win()`: `0x401464` (each time we run the program, this doesn't change), and enter the `challenge`, we can know that the `buffer` is at `rbp-0x60`, so the return address will be at `buffer[104]`
- *level 6.0*: we need to overwrite the return address of `challenge()` to execute `win_authed()`, there is a check inside `win_authed()`, we need to return to the position after that check
- *level 6.1*: buffer is at `rbp-0x50`, so we need to put the destination address at `buffer[88]`. We can use `x/80i *win_authed` to see where the jump is in `win_authed()`. We need to jump to `win_authed+28` (`0x401d3a`)
- *level 7.0*: in previous few tasks, the memory address of functions are the same in each run. This time the binary is position independent. 
- *level 7.1*
- *level 8.0*
- *level 8.1*
- *level 10.0*
- *level 10.1*
### Program Exploitation