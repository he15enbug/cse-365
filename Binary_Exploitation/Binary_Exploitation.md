# Binary Exploitation
## Background Knowledge
### Shellcode
- We ususally use shellcode to run `execve("/bin/sh", NULL, NULL)`, in this class, we run `sendfile(1, open("/flag", NULL), 0, 1000)` to read the flag by exploiting a privileged program
- *Building Shellcode*
    1. Write the shellcode as assembly
    2. And then assemble it using `gcc -nostdlib -static shellcode.s -o shellcode-elf`, the ELF has our shellcode as its `.text`
    3. Extract the `.text`: `objcopy --dump-section .text=shellcode-raw shellcode-elf`
    4. Now, `shellcode-raw` contains the raw bytes of our shellcode
- Test the shellcode
    - Run the ELF: `./shellcode-elf`
    - Write a shellcode loader in C:
        ```
        page = mmap(0x1337000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, 0, 0);
        read(0, page, 0x1000);
        ((void(*)())page)();
        ```
        - `cat shellcode-raw | ./tester`
- Debugging Shellcode:
    - `stract ./shellcode-elf`
    - `gdb ./shellcode-elf`
        - we can hardcode breakpoints in the shellcode using `int3` instruction
## Challenges
### Web Security
- *level 15*: there is a buffer overflow vulnerability, the program will store a string `Hello, <USER_INPUT>!` into a 256-byte buffer, but there isn't a size check on the user input. The server provides a function to print out the address of the `win()` function, which displays the flag. What we need to do is to overwrite the return address of the `greet()` function to the address of `win()`. The structure of the current stack frame is (from low address to high address):
    - `[buffer (256 bytes)][previous rbp (8 bytes)][return address]` (stack layout)
    - `['Hello, ' (7 bytes) +  padding (257 bytes)][  win_address ]` (buffer overflow)
### Shellcode Injection
- *level 1*: it will take in the raw bytes of our shellcode, and execute it on stack. We should put our data on stack instead of in `.data` section
- *level 2*: it will randomly skip up to `0x800` bytes of our code, to increase the probability that our instructions are not skipped, pad `0x900` bytes of NOPs (`0x90`) to our program
    - `.fill 0x900, 1, 0x90`
- *level 3*: we cannot have NULL bytes (`0x00`) in our shellcode. We can achieve that by replacing `mov <REGISTER>, 0` to `xor <REGISTER>, <REGISTER>`. Besides, `mov rax, 0x67616c662f` will also contain NULL bytes, because `0x67616c662f` will be padded to 8 bytes (`rax` is 8-byte register), there are many tricks to eliminate the NULL bytes, e.g.:
    ```
    # mov rax, 0x67616c662f
    mov rax, 0x67616c662f777777
    shr rax, 24
    ```
### Memory Errors
- *level 1.0*: pretty straightforward, just overflow the buffer with any non-zero bytes to change the `win` byte to non-zero
- *level 1.1*: this time, the stack information is not given. First, try a longer input, e.g., 600 bytes, and we get the flag
- *level 2.0*: set the variable `win` to a given value
- *level 2.1*: this time, no useful information is printed out, debug the program to find the way to get the flag. We can know the buffer is at `rbp-0x60`, and there are 2 key jumping
    ```
    0x55df49fc3425 <challenge+188>:      call   0x55df49fc2180 <read@plt>
    0x55df49fc342a <challenge+193>:      mov    DWORD PTR [rbp-0x7c],eax
    0x55df49fc342d <challenge+196>:      cmp    DWORD PTR [rbp-0x7c],0x0
    0x55df49fc3431 <challenge+200>:      jns    0x55df49fc345f <challenge+246>
    ...
    0x55df49fc345f <challenge+246>:      mov    rax,QWORD PTR [rbp-0x68]
    0x55df49fc3463 <challenge+250>:      mov    eax,DWORD PTR [rax]
    0x55df49fc3465 <challenge+252>:      cmp    eax,0x3be21a84
    0x55df49fc346a <challenge+257>:      jne    0x55df49fc3476 <challenge+269>
    0x55df49fc346c <challenge+259>:      mov    eax,0x0
    0x55df49fc3471 <challenge+264>:      call   0x55df49fc326c <win>
    ```
    - `DWORD PTR [rbp-0x7c]` is the return value of `read()`, as long as it succeed to read our data, it returns a non-negative value. So, our goal is to set the 4-byte value at `[rbp-0x68]` to `0x3be21a84`. To know the address of this value, we need to figure out the content in `rbp-0x68`: it's `rbp-0x18`. So, we need to set the value at `buffer[72]`
        ```
        0x55df49fc33c0 <challenge+87>:       lea    rax,[rbp-0x60]
        0x55df49fc33c4 <challenge+91>:       add    rax,0x48
        0x55df49fc33c8 <challenge+95>:       mov    QWORD PTR [rbp-0x68],rax
        ```
    - After that, there will also be a stack check, to bypass it, we need the `xor` result to be zero. At the beginning of both `main()` and `challenge()`, `QWORD PTR fs:0x28` is put into `QWORD PTR [rbp-0x8]`, we just need to ensure we don't overwrite it when causing a buffer overflow (our input should be at most 88 bytes)
        ```
        0x55df49fc3482 <challenge+281>:      mov    eax,0x0
        0x55df49fc3487 <challenge+286>:      mov    rcx,QWORD PTR [rbp-0x8]
        0x55df49fc348b <challenge+290>:      xor    rcx,QWORD PTR fs:0x28
        0x55df49fc3494 <challenge+299>:      je     0x55df49fc349b <challenge+306>
        0x55df49fc3496 <challenge+301>:      call   0x55df49fc2150 <__stack_chk_fail@plt>
        0x55df49fc349b <challenge+306>:      leave  
        ```
- *level 3.0*: overwrite the return address to `0x402265` at `buffer[136]`
- *level 3.1*: debug the program to find the address of `win()`: `0x401464` (each time we run the program, this doesn't change), and enter the `challenge`, we can know that the `buffer` is at `rbp-0x60`, so the return address will be at `buffer[104]`
- *level 6.0*: we need to overwrite the return address of `challenge()` to execute `win_authed()`, there is a check inside `win_authed()`, we need to return to the position after that check
- *level 6.1*: buffer is at `rbp-0x50`, so we need to put the destination address at `buffer[88]`. We can use `x/80i *win_authed` to see where the jump is in `win_authed()`. We need to jump to `win_authed+28` (`0x401d3a`)
- *level 7.0*: in previous few tasks, the memory address of functions are the same in each run. This time the binary is position independent. Run the program multiple times, and we can find out that the distance between the original return address (`main+238`) and the target return address (`win_authed+28`) is fixed, and each time, the least 12 bits of `main+238` is `fbe`, and the least 12 bits of `win_authed+28` is `718`, and higher bits of the two addresses are the same. We can overflow the buffer to only modify the least 12 bits. However, the smallest unit we can overwrite is 1 byte, to modify 12 bits, we need to overwrite at least 2 bytes, the highest 4 bits in the 2 bytes should be exactly the same as in the original return address, we can do this by trying multiple times until we "accidently" hit the correct value
- *level 7.1*: same as 7.1
- *level 8.0*: The buffer starts from `rbp-0x40`, and the lowest 12 bits of `win_authed+28` is `0x7dc`. This time, the input will be put in a correctly-sized temporary buffer, and then be copied over to the stack. After reading our input, it will use `strlen` to check the size of our input, and it must be no longer than 20 bytes (we can just put at least one `\x00` in the first 20 bytes of our input, because `strlen()` stops when it sees `0x00`)
- *level 8.1*: same as 8.1, buffer starts from `rbp-0x90`
- *level 10.0*: buffer is from `rbp-0x180`. This time there is no `win_authed()` function. The program will load the flag into the memory, but will not print it out. First, analyze the code of `challenge()`
    1. the buffer is from `rbp-0x180`, the address to store the flag is from `rbp-0x10f` (`rbp-0x180+0x71`, `buffer[113]`)
    2. call `open()` to open `/flag`, and `read()` from the FD of `/flag` to `buffer[113]`
    3. `scanf()` the input size, and then `read()` from standard input to the buffer
    4. check the canary to ensure that the return address is not modified (by overflow)
    5. the program will finally *print out* what we input to the buffer, as long as we pad the content before `buffer[113]` with non-zero bytes, it will print out the flag!
- *level 10.1*: flag is at (`buffer[0x2c]`)
### Program Exploitation
- *level 1.0*: our input will be stored in a buffer, and will be mapped to `0x2f2e7000` (`0x1000` bytes). We need to first overflow the buffer to overwrite the return address to the start of our shellcode. There are 72 bytes from the start of the buffer to the return address
- *level 1.1*: debug the program, the address being `mmap()`ed is `0x1e0ce000`, the buffer is from `rbp-0x70`, so we need to pad `0x78` bytes, and then overwrite the return address to `0x1e0ce000`
- *level 2.0*: this time, we need to include our shellcode in the input, the buffer is from `rbp-0x78`, there is no *ASLR*, each time the stack layout is the same, that means we can hardcode the return address to our shellcode. This is the structure of our input
    - `[0x80 bytes padding][0x00007fffffffd2a0][shellcode]`
- *level 2.1*: buffer `rbp-0x40`, we need `0x48` bytes to reach the return address. One thing we need to take care of it that in `gdb`, the memory address is slightly different compared to running the program directly, because `gdb` sets extra environment variables. I solved this by padding a lot of (approximately 800 bytes) NOPs (`0x90`) before the shellcode, and adjust the target address I got when debugging the program. If we are lucky, we will return to somewhere inside the 800 bytes of NOPs, and the shellcode will finally get executed

